# 알고리즘
_____
### 🔴 자료구조

| |배열|벡터|연결리스트| 
|:---|:---:|:---:|:---:|
|삽입/삭제|O(N)|O(N)|O(1)|
|탐색|O(1)|O(1)|O(N)|

⭐ 벡터는 동적 배열

| |스택|큐|우선순위 큐|          
|:---|:---:|:---:|:---:|       
|삽입/삭제|O(1)|O(1)|O(logN)|     
|특징|LIFO|FIFO|FIFO|

 ⭐ 자바에서는 낮은 숫자가 우선순위가 높음(오름차순)
 
 new Comparator<>() -> int compare 상속
 
 implements Comparable<> -> int compareTo 상속

| |맵|집합|           
|:---|:---:|:---:|
|삽입/삭제|O(1)|O(1)|
|특징|key, value (key는 중복 허용 X)|중복 허용 X|

⭐ Map 주요 메서드
- V put(key, value)
- V remove(key)
- V getOrDefault(key, defaultValue)
- Set<Map.Entry<K,V>> entrySet()
- Set<K> keySet()
- Collection<V> values()
_____
### 🔴 브루트 포스
장점: 반드시 정답을 찾을 수 있음

단점: 시간이 오래 걸린다

ex) 비밀번호 숫자 4자리, 4색 정리 증명
_____
### 🔴 탐욕법(Greedy)
매순간마다 최선의 경우만 탐색

완전탐색보다 빠르다
_____
### 🔴 그래프
- SNS/메신저
- VCS
- 지하철 노선도

![Graph](https://chamdom.blog/static/43dcc5ebdae930f808c5563ac31f4159/b5a09/directed-and-undirected.png)

DAG : 방향성 비순환 그래프

ex) VCS

![DAG](https://www.astronomer.io/archive/4XcEQDyaAVp5gIzgSzBWN9/bc051c27cf8bac823b6f5f14d3edd911/Untitled-1.webp)

||인접 행렬|인접 리스트|
|:---|:---|:---|
|구현|행렬|리스트|
|비교|메모리를 많이 차지하지만 속도가 빠름|메모리를 적게 차지하지만 속도가 느림|

||DFS|BFS|
|:---|:---|:---|
|구현|스택 or 재귀 함수||
|시간복잡도|O(V²), O(V+E)|O(V²), O(V+E)| ✔️ 행렬, 리스트
|응용|단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬|최단 거리 탐색|
_____
### 🔴 이분 탐색
- 정렬이 되어 있어야 탐색 가능
- 시간복잡도 (OlogN)

⭐ lower_bound, upper_boud, 파라메트릭 서치
_____
### 🔴 동적 계획법
||Top-down|Bottom-up|
|:---|:---|:---|
|구현|재귀|반복문|
|저장|매모이제이션|타뷸레이션|

**메모이제이션**은 재귀함수 호출로 인해 속도가 저하될 수 있음
_____
### 🔴 구간 합
합 배열 S 정의 : S[i] = A[0] + A[1] + A[2] + ......... + A[i-1] + A[i]

합 배열 S 만드는 공식 : S[i] = S[i-1] + A[i]

i~j까지 구간 합 : S[j] - S[i-1]
_____
### 🔴 정렬
||버블 정렬|선택 정렬|삽입 정렬|퀵 정렬|병합 정렬|기수 정렬|
|:---|:---|:---|:---|:---|:---|:---|
|시간복잡도|O(n²)|O(n²)|O(n²)|O(nlogn)|O(nlogn)|O(kn)|
|구현|Swap|Swap|이진 탐색|Pivot|분할 정복|값 비교 X|
_____
### 🔴 정수론
##### 소수 구하기
1. 에라토스테네스의 체
 1. 수의 범위만큼 배열 생성
 2. 2부터 시작하여 현재 수가 지워지지 않을 때는 현재 선택된 수의 배수에 해당하는 수를 배열에서 끝까지 탐색하여 지운다. 처음 선택된 수는 지우지 않는다.

##### N과 서로소인 자연수의 개수 구하기
1. 오일러 피
 1. 수의 범위만큼 배열 생성
 2. 2부터 시작하여 현재 배열의 값과 인덱스가 같음ㄴ 현재 선택된 수(K)의 배수에 해당하는 수를 배열에서 끝까지 탐색하여 P[i] -= (P[i]/K) 연산 수행

##### 두 수의 최대공약수 구하기
1. 유클리드 호제법
 1. 큰 수를 작은 수로 나누는 MOD 연산
 2. 1에서의 작은 수와 MOD 연산 결괏값으로 MOD 연산
 3. 나머지가 0이 되는 순간의 작은 수가 최대공약수
_____
### 🔴 유니온 파인드
Union 연산 : 각 노드가 속한 집합을 1개로 합치는 연산

Find 연산 : 특정노드 a에 대해 a가 속한 집합의 대표 노드를 반환하는 연산
_____
### 🔴 위상 정렬
사이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘 **항상 유일한 값으로 정렬 X**

⭐ 진입 차수 배열, Queue 사용
_____
### 🔴 다익스트라
|기능|특징|시간복잡도|
|:---|:---|:---|
|출발노드와 모든 노드간의 최단거리 탐색|에지는 모두 양수|O(ElogV)|

⭐ 최단거리 배열, (도착노드, 거리)쌍의 배열, 거리 기준 PriorityQueue 사용
_____
### 🔴 벨만-포드
|기능|특징|시간복잡도|
|:---|:---|:---|
|특정 출발 노드에서 다른 모든 노드까지의 최단 경로 탐색|음수 가중치 에지가 있어도 수행 가능<br>전체 그래프에서 음수 사이클의 존재 여부 판단 가능|O(VE)|

⭐ 최단거리 배열, (출발 노드, 도착노드, 거리) 쌍의 배열 사용
_____
### 🔴 플로이드-위셜
|기능|특징|시간복잡도|
|:---|:---|:---|
|모든 노드 간에 최단 경로 탐색|음수 가중치 에지가 있어도 수행 가능<br>동적 계획법의 원리를 이용해 알고리즘에 접근|O(V²)|
_____
### 🔴 최소신장트리
그래프에서 모든 노드를 연결할 때 사용된 에지들의 합을 최소로 하는 트리
- 사이클 포함 X
- 최소 신장 트리를 구성하는 에지의 개수 : N - 1 (N은 노드 수)

⭐ (노드 1, 노드 2, 가중치) 쌍의 배열, union-find, 우선순위 큐 사용
_____
### 🔴 트라이
문자열 검색을 빠르게 실행할 수 있도록 설계한 트리 형태의 자료구조
_____
### 🔴 이진 트리
![Binary Tree](https://velog.velcdn.com/images/rokky/post/fba4d7fb-24b4-4223-be70-dbe5965e7f1f/image.png)
_____
### 🔴 세그먼트 트리
구간 합과 데이터 업데이트를 빠르게 수행하기 위한 자료구조

트리 초기화: 2^k >= N (데이터의 수) 만족하는 K의 최솟값

세그먼트 트리의 index = 주어진 index + 2^k - 1
_____
### 🔴 최소 공통 조상
트리 그래프에서 임의의 두 노드를 선택했을 때 두 노드가 각각 자신을 포함해 거슬러 올라가면서 부모 노드를 탐색할 때 처음 공통으로 만나게 되는 부모 노드

⭐ 빠르게 구하기

부모 노드 배열 점화식 P[K][N] = P[K-1][P[K-1][N]]
_____



